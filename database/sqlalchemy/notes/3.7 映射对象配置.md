# 3.7 映射对象配置

比如计算字段, 关系字段等.



* `column_property()`: 定义计算属性, 该字段不会出现在数据库中, 但是可以通过对象直接访问

  * ```python
    from typing import List
    from typing import Optional
    
    from sqlalchemy import Column
    from sqlalchemy import ForeignKey
    from sqlalchemy import String
    from sqlalchemy import Text
    from sqlalchemy.orm import column_property
    from sqlalchemy.orm import DeclarativeBase
    from sqlalchemy.orm import Mapped
    from sqlalchemy.orm import mapped_column
    from sqlalchemy.orm import relationship
    
    
    class Base(DeclarativeBase):
        pass
    
    
    class User(Base):
        __tablename__ = "user"
    
        id: Mapped[int] = mapped_column(primary_key=True)
        name: Mapped[str]
        firstname: Mapped[str] = mapped_column(String(50))
        lastname: Mapped[str] = mapped_column(String(50))
        # 数据库中不会出现该字段, 但是可以直接通过映射对象操作
        fullname: Mapped[str] = column_property(firstname + " " + lastname)
    
        addresses: Mapped[List["Address"]] = relationship(back_populates="user")
    
    
    class Address(Base):
        __tablename__ = "address"
    
        id: Mapped[int] = mapped_column(primary_key=True)
        user_id: Mapped[int] = mapped_column(ForeignKey("user.id"))
        email_address: Mapped[str]
        address_statistics: Mapped[Optional[str]] = mapped_column(Text, deferred=True)
    
        user: Mapped["User"] = relationship(back_populates="addresses")
    ```

* `__abstract__`: bool值, 设置基类是否为抽象类, 如果为True, 那么在建表时不会创建该表. 比如可以创建多个不同的Base, 用以对表进行分组.

  * ```python
    class Base(DeclarativeBase):
        pass
    
    
    class DefaultBase(Base):
        __abstract__ = True
        metadata = MetaData()
    
    
    class OtherBase(Base):
        __abstract__ = True
        metadata = MetaData()
        
    DefaultBase.metadata.create_all(some_engine)
    OtherBase.metadata.create_all(some_other_engine)    
    ```

* 

