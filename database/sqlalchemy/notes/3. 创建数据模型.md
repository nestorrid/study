# 创建数据模型

sqlalchemy通过`MetaData`对象来存储表结构的信息, 以此来批量的完成对数据模型的操作.

## 直接定义表

也可以直接通过对象来定义表

```python
import sqlalchemy
from sqlalchemy import String, Integer

meta = sqlalchemy.MetaData()

records = sqlalchemy.Table(
    'records', meta,
    sqlalchemy.Column('record_id', Integer, primary_key=True),
    sqlalchemy.Column('name', String(50), unique=True, nullable=False)
)

```

> 直接通过`Table`类创建表是一种比较基础的定义形式, 在2.0之后通常使用类来进行模型定义
> 但是对于某些不需要创建类的表同样也可以使用此种方式来进行定义, 比如在多对多关系里的中间关系表

## 定义式数据模型

通过一个继承自`DeclarativeBase`的类来作为所有模型类的基类.

该类内置了一个`metadata`对象, 每一个子类都使用该对象来作为自身的`metadata`, 每个子类是一张表, 在子类中进行对于表的定义即可.

```python
import sqlalchemy
from sqlalchemy import Column, String, Integer, create_engine
from sqlalchemy.orm import DeclarativeBase


class Base(DeclarativeBase):
    pass


class Record(Base):
    __tablename__ = 'records'

    id = Column('record_id', Integer, primary_key=True)
    name = Column('name', String(50), unique=True)
```



##  类型映射

通过`Mapped`类可以将python类型映射为数据库类型, 在定义字段时可以直接声明字段类型. 如果存在更多的字段约束, 则可以通过`mapped_column`进行赋值. 

> `mapped_column` 是2.0版本新增加的功能, 取代了直接使用`Column()`对象的方式, 提供了一些增强的配置功能.

对添加了Mapped类型的字段, 可以不进行赋值, 框架会自动为其添加一个`mapped_column()`.

```python
class Base(DeclarativeBase):
    pass


class User(Base):
    __tablename__ = "user"

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(50))
    fullname: Mapped[Optional[str]]
    nickname: Mapped[Optional[str]] = mapped_column(String(30))
```

可用的类型映射包括:

```python
type_map: Dict[Type[Any], TypeEngine[Any]] = {
    bool: types.Boolean(),
    bytes: types.LargeBinary(),
    datetime.date: types.Date(),
    datetime.datetime: types.DateTime(),
    datetime.time: types.Time(),
    datetime.timedelta: types.Interval(),
    decimal.Decimal: types.Numeric(),
    float: types.Float(),
    int: types.Integer(),
    str: types.String(),
    uuid.UUID: types.Uuid(),
}
```



