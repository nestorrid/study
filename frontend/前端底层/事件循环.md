---
title: 事件循环
date: 2023-12-06 20:52:45 +08000
categories: [笔记, 前端]
tags: [frontend]
---

## 进程和线程

简单理解, 一个程序就是一个进程.

程序启动是自动创建的一个线程就是主线程, 主线程结束代表程序运行结束.

一个进程可以包含多个线程.

## 浏览器的进程和线程

浏览器是一个多进程多线程的应用程序.

浏览器主要的进程包括:

* 浏览器进程: 界面显示, 用户交互, 子进程管理等.
* 网络进程: 负责加载网络资源.
* 渲染进程: 开启一个渲染主线程, 负责执行html,css,js代码. 默认情况下, 每个标签页都有一个独立的渲染进程.

事件循环便是在渲染进程的主线程之中.

## 渲染主线程

执行的任务主要包括:

* 解析 HTML
* 解析 css
* 计算样式
* 布局
* 处理图层
* 每秒60帧重绘
* 执行js代码
* 执行时间处理函数
* 执行计时器的回调函数
* 等等

浏览器主线程通过消息队列来处理任务调度. 渲染主线程在创建时便会进入一个死循环, 持续监听消息队列, 当队列中所有任务完成后渲染主线程便会进入休眠.

比如用户操作监听的线程, 计时器线程等触发操作时, 会将处理任务放入队列, 而渲染主线程则是在当前任务完成之后从消息队列中获取下一个任务.

## 通过事件循环解决异步处理的问题

一些无法立即处理的任务, 比如:

* 计时器完成后需要执行的任务, setTimeou, setInterval
* 网络通信完成后需要执行的任务, Fetch
* 用户操作后需要执行的任务, addEventListener

如果主线程需要等待执行结束, 便会进入阻塞状态, 而主线程阻塞便会造成浏览器卡死.

因此主线程会将需要等待的任务交由其他线程处理, 待线程处理完成后, 会向队列中添加新的任务, 主线程再次获取任务时将其执行.

以计时器为例:

```text
Main:       start, wait,                              run(callback)
Queue: 计时                                   callback
Timer:              start, counting, timeout
```

一个经典的卡死案例:

```vue
<script setup lang="ts">
import { ref } from 'vue';

const message = ref("some text")

function clickHandler() {
    message.value = "new text"
    const start = Date.now()
    while (Date.now() - start < 3000) { }
}
</script>

<template>
    <p>{{ message }}</p>
    <button @click="clickHandler">refresh</button>
</template>
```

当点击按钮时更新了响应式数据message, 同时进入3秒的死循环. 那么界面会在点击时更新还是3秒后更新?

> * 渲染主线程创建按钮的监听事件;
> * 用户点击按钮, 将事件函数封装为任务放入消息队列
> * 主线程拿到任务, 开始执行
> * 修改`message`变量的值, 同时添加渲染页面任务到消息队列
> * 进入循环等待结束
> * 循环结束, 点击处理函数运行结束
> * 拿到消息队列中的渲染任务, 最终更新页面.
>
{: .prompt-info}

简单来说, 修改变量和等待循环是同一个任务, 而更新页面是另一个任务, 渲染主线程只有当当前任务结束后才能进行渲染任务. 所以界面要在等待3秒之后才会更新.

## 渲染主线程的优先级

渲染主线程本身没有优先级, 仅执行消息队列给出的任务. 而消息队列则是采用FIFO(First in first out), 即先进先出的规则.

而消息队列本身包含多个队列, 同一个类型的任务必须在同一个队列, 而不同类型的任务可以在不同的队列, 比如:

* 用户操作任务
* 网络任务
* 计时器任务
* 等等

根据w3c的规定, 浏览器必须包含一个`microtask queue`, 微任务队列, 在该队列中的任务不为空时所有其他队列都需要等待.

不同的任务队列可以拥有不同的优先级, 不同的浏览器底层处理会有差异.

以谷歌浏览器来说, 主要包含的队列包括:

* 延时队列: 计时器的回调, 中优先级;
* 交互队列: 用户操作的处理任务, 高优先级;
* 微队列: 用户指定需要最快执行的任务, 优先级最高.

可以使用`Promise.resolve().then(()=>{})`来将任务放入微队列, 具有最高的优先级.

```javascript
setTimeout(() => {
    console.log(1)
}, 0);

Promise.resolve().then(() => {
    console.log(2);
})

console.log(3);
```

输出结果为:3 2 1.

由于函数作为同一个任务, 需要完整执行后才会进行其他任务, `setTimeout`和`Promise`都不会即时输出, 所以优先输出3.

而`setTimeout`创建的任务在延时队列中, `Promise`创建的任务则是在微队列中, 具有更高的优先级, 所以先输出2, 最后输出1.
