浏览器原理
================================================

浏览器渲染原理
------------------------------------------------

浏览器渲染的本质: 把html的字符串信息转化为屏幕的像素信息.

当请求一个URL时:

1. 网络线程与服务器进行通信;
2. 获取对应的HTML;
3. 将渲染任务放入消息队列;
4. 渲染主线程执行渲染任务.

大致的渲染流程
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

主线程:

1.  解析HTML源码, 获取Dom对象(Document Object Model)和Cssom对象(Css Object Model).

    由于css的下载和解析实在独立的线程上执行, 所以css解析不会阻塞解析html.
    而js则会直接被执行. 但与css有区别的地方在于js的下载会阻塞html解析, 如果存在外部js, 必须等待js下载完成并执行结束之后才会继续解析.

#. 基于Dom和Cssom进行样式计算;
#. 根据样式进行布局;
#. 对布局进行分层, 用以优化重绘的效率;
#. 生成绘制指令, 类似canvas指令;

在主线程生成了最终的绘制指令集之后, 将交由其他线程进行后续步骤:

#. 将每一层分成多个块, 再将不同的块通过线程池进行多线程绘制;
#. 光栅化, 将每个块变成位图, 会优先处理可见范围内的部分, 这一步会交由GPU进行加速, 最终得到所有块的位图信息;
#. 将所有的位图信息交给浏览器的GPU进程, 最终调用硬件接口完成显示.

reflow
    当修改可见dom元素, 或者修改影响布局的样式信息, 如宽度, 高度, 间距等属性时就会产生对布局的重新计算, 也就是reflow.

    当在连续修改属性时, 浏览器为了优化执行效率, 不会立即进行reflow, 而是在所有设置完成后统一reflow.

    但为了保证获取信息的正确性, 只要进行属性的读取, 便会立即进行reflow并返回计算后的值.

repaint
    对于不修改几何信息的改动, 比如颜色, 则不会运行全部的渲染流程, 主线程仅仅需要执行第五步, 即重新生成绘制指令便可将剩余的操作交由合成线程来完成. 效率便会比reflow更高. 但reflow必然会引起repaint.

transform
    在css中可以使用animation直接修改属性生成动画, 也可以配合transform完成动画. 但是transform本身并不会对页面的几何信息产生任何影响, 而是直接修改交由GPU的位图信息, 也就不会触发reflow, repaint等前置流程. 也就有着更高的执行效率, 同时也不会造成主线程阻塞, 甚至在主线程阻塞的情况下依然可以正常执行.

    在下面的例子中, 通过两个css动画进行演示:

    .. code-block::
    
        <script setup lang="ts">

        function blockPage() {
            const start = Date.now();
            while (Date.now() - start < 3000) { }
        }

        </script>


        <template>
            <div>
                <div class="ball ball1"></div>
                <div class="ball ball2"></div>
            </div>
            <button @click="blockPage" style="margin-top: 120px;">block</button>
        </template>


        <style scoped lang="scss">
        .ball {
            width: 100px;
            height: 100px;
            background-color: red;
            margin-bottom: 10px;
            border-radius: 50%;
            left: 650px;

            &1 {
                animation: move1 1s infinite ease-in-out;
                animation-direction: alternate;
            }


            &2 {
                position: fixed;
                animation: move2 1s alternate infinite ease-in-out;
            }
        }

        @keyframes move1 {
            to {
                transform: translate(100px);
            }
        }

        @keyframes move2 {
            to {
                left: 750px;
            }
        }
        </style>


由于move2动画是直接修改元素的样式属性, 也就会修改页面元素的几何信息, 引起布局的变化, 从而导致在渲染主线程中进行reflow. 而当主线程在执行其他任务进阻塞状态时, 无法处理渲染任务, 动画就会停止.

而move1动画由于是通过transform完成, 并没有修改元素原本的任何布局信息, 仅仅只是修改了发送给GPU的位图绘制信息, 即便主线程进入阻塞, 依然可以顺畅的运行.

------------------------------------------------

事件循环
------------------------------------------------

进程和线程
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

简单理解, 一个程序就是一个进程.

程序启动是自动创建的一个线程就是主线程, 主线程结束代表程序运行结束.

一个进程可以包含多个线程.

浏览器的进程和线程
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

浏览器是一个多进程多线程的应用程序.

浏览器主要的进程包括:

* 浏览器进程: 界面显示, 用户交互, 子进程管理等.
* 网络进程: 负责加载网络资源.
* 渲染进程: 开启一个渲染主线程, 负责执行html,css,js代码. 默认情况下, 每个标签页都有一个独立的渲染进程.

事件循环便是在渲染进程的主线程之中.

渲染主线程
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

执行的任务主要包括:

* 解析 HTML
* 解析 css
* 计算样式
* 布局
* 处理图层
* 每秒60帧重绘
* 执行js代码
* 执行时间处理函数
* 执行计时器的回调函数
* 等等

浏览器主线程通过消息队列来处理任务调度. 渲染主线程在创建时便会进入一个死循环, 持续监听消息队列, 当队列中所有任务完成后渲染主线程便会进入休眠.

比如用户操作监听的线程, 计时器线程等触发操作时, 会将处理任务放入队列, 而渲染主线程则是在当前任务完成之后从消息队列中获取下一个任务.

通过事件循环解决异步处理的问题
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

一些无法立即处理的任务, 比如:

* 计时器完成后需要执行的任务, setTimeou, setInterval
* 网络通信完成后需要执行的任务, Fetch
* 用户操作后需要执行的任务, addEventListener

如果主线程需要等待执行结束, 便会进入阻塞状态, 而主线程阻塞便会造成浏览器卡死.

因此主线程会将需要等待的任务交由其他线程处理, 待线程处理完成后, 会向队列中添加新的任务, 主线程再次获取任务时将其执行.

以计时器为例:

.. code-block:: 

    Main:       start, wait,                              run(callback)
    Queue: 计时                                   callback
    Timer:              start, counting, timeout

一个经典的卡死案例:

.. code-block::

    <script setup lang="ts">
    import { ref } from 'vue';

    const message = ref("some text")

    function clickHandler() {
        message.value = "new text"
        const start = Date.now()
        while (Date.now() - start < 3000) { }
    }
    </script>

    <template>
        <p>{{ message }}</p>
        <button @click="clickHandler">refresh</button>
    </template>


当点击按钮时更新了响应式数据message, 同时进入3秒的死循环. 那么界面会在点击时更新还是3秒后更新?

* 渲染主线程创建按钮的监听事件;
* 用户点击按钮, 将事件函数封装为任务放入消息队列
* 主线程拿到任务, 开始执行
* 修改 `message` 变量的值, 同时添加渲染页面任务到消息队列
* 进入循环等待结束
* 循环结束, 点击处理函数运行结束
* 拿到消息队列中的渲染任务, 最终更新页面.


简单来说, 修改变量和等待循环是同一个任务, 而更新页面是另一个任务, 渲染主线程只有当当前任务结束后才能进行渲染任务. 所以界面要在等待3秒之后才会更新.

渲染主线程的优先级
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

渲染主线程本身没有优先级, 仅执行消息队列给出的任务. 而消息队列则是采用FIFO(First in first out), 即先进先出的规则.

而消息队列本身包含多个队列, 同一个类型的任务必须在同一个队列, 而不同类型的任务可以在不同的队列, 比如:

* 用户操作任务
* 网络任务
* 计时器任务
* 等等

根据w3c的规定, 浏览器必须包含一个`microtask queue`, 微任务队列, 在该队列中的任务不为空时所有其他队列都需要等待.

不同的任务队列可以拥有不同的优先级, 不同的浏览器底层处理会有差异.

以谷歌浏览器来说, 主要包含的队列包括:

* 延时队列: 计时器的回调, 中优先级;
* 交互队列: 用户操作的处理任务, 高优先级;
* 微队列: 用户指定需要最快执行的任务, 优先级最高.

可以使用 `Promise.resolve().then(()=>{})` 来将任务放入微队列, 具有最高的优先级.

.. code-block:: javascript

    setTimeout(() => {
        console.log(1)
    }, 0);

    Promise.resolve().then(() => {
        console.log(2);
    })

    console.log(3);


输出结果为:3 2 1.

由于函数作为同一个任务, 需要完整执行后才会进行其他任务, `setTimeout` 和 `Promise` 都不会即时输出, 所以优先输出3.

而 `setTimeout` 创建的任务在延时队列中, `Promise` 创建的任务则是在微队列中, 具有更高的优先级, 所以先输出2, 最后输出1.
